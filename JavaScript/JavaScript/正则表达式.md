# 正则表达式

## 基本语法

正则表达式（Regular Expression）是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。

###创建

JavaScript通过内置对象RegExp支持正则表达式，有两种方式创建正则表达式对象，如果我们想匹配字符串中<%xxxx%>两个百分号分割的字符串可以这么写

1. 构造函数 
```js
    var reg= new RegExp('<%[^%>]+%>','g');
```

2. 字面量
```js
    var reg=/<%[^%>]%>/g;
```

最后的g代表全局，还有几个修饰符：
1. g:global，全文搜索，不添加的话搜索到第一个结果停止搜索
2. i:ignore case，忽略大小写，默认大小写敏感
3. m:multiple lines,多行搜索


###元字符

`( [ { \ ^ $ | ) ? * + .`


###字符类
 
 一般情况下正则表达式一个字符（转义字符算一个）对应字符串一个字符，表达式`ab\t`的含义是
 但是我们可以使用元字符[]来构建一个简单的*类*，所谓类是值，符合某些特征的对象，是一个泛指，而不是特指某个字符了，我们可以使用表达式 `[abc]` 把字符a或b或c归为一类，表达式可以匹配这类的字符image


###取反

元字符  `[]`组合可以创建一个类，我们还可以使用元字符`^`创建*反向类/负向类*，反向类的意思是不属于XXX类的内容，表达式`[^abc]`表示不是字符a或b或c的内容

### 范围

###边界

###量词

```js
    //如何判断输入的数字是一个手机号
    var str1= '13011112222'
    var str2= 'aa13011112222'
    var str3= '130111122229999'
    var str4= '130aaaa2222'
    str1.match(/^1[3578]\d{9}$/g)
```


##正则表达式贪婪与非贪婪模式

```js
    var str = 'a "witch" and her "broom" is one' ;
    str.match(/".*"/g);
    //按照预想匹配结果应是"witch" 和 "broom" 两个字符串，但实际上是"witch" and her "broom" 一个字符串，这就是正则的贪婪模式在起作用
```
* 在贪婪（默认）模式下，正则引擎尽可能多的重复匹配字符，`+ *`都是贪婪模式

### 非贪婪模式

非贪婪模式可通过在代表数量的标示符后放置`？`来开启非贪婪模式，如`?  +?  ??`

```js
    var str = 'a "witch" and her "broom" is one' ;
    str.match(/".*?"/g);      //"witch"  "broom"
```

```js
    '123456789'.match(/\d{3,5}/g)     //["12345", "6789"]
    '123456789'.match(/\d{3,5}?/g)    //["123", "456", "789"]
```


## 分组

有时候我们希望使用量词的时候匹配多个字符，就可以使用`()`达到目的，称为分组
```js
    (Byron){20}
```

## 或

如果希望匹配Byron或Casper出现20次，可以使用字符`|`达到目的
```js
    (Byron|Casper){20}
```

##前瞻

|表达式|含义|
|--|--|
|exp1(?=exp2)|匹配后面是exp2的exp1|
|exp1(?!exp2)|匹配后面不是exp2的exp1|


##RegExp.prototype.exec(str)

方法用于正则表达式模式在字符串中运行查找，如果exec()找到了匹配的文本，则返回一个结果数组，否则返回null

* 除数组元素和length属性之外，exec()方法返回对象还包括两个属性
    1. index属性声明的是匹配文本的第一个字符的位置
    2. input属性则存放的是被检索的字符串string

**全局调用**
调用全局的RegExp对象的exec()时，它会在RegExp实例的lastIndex属性指定的字符处开始检索字符串string
1. 当exec()找到了与表达式相匹配的文本时，在匹配后，它将把RegExp实例的lastIndex属性设置为匹配文本的最后一个字符的下一个位置。可以通过反复调用exec()方法来遍历字符串中的所有匹配文本
2. 当exec()再也找不到匹配的文本时，它将返回null，并把lastIndex属性重置为0

**非全局调用**
调用非全局的RegExp对象的exec()时，返回数组的第一个元素是与正则表达式相匹配的文本，第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话），第三个元素时与RegExp对象的第二个子表达式相匹配的文本（如果有的话），以此类推。


## String.prototype.split(reg)

* 我们经常使用split方法吧字符串分割为字符数组
```js
    'a,b,c,d'.split(',');   //["a","b","c","d"]
    //和replace方法类似，在一些复杂的分割情况下我们可以使用正则表达式
    'a1b2c3d'.split(/\d/);   //["a","b","c","d"]
```



## 正则实现trim()

    ```js
        function trim(string){
            return string.replace(/^\s+|\s+$/g,'')
        }
    ```


##课后习题

```js
//判断用户输入的是不是手机号。
function isPhoneNum(str){
    if(str.search(/^1[3578]\d{9}$/g)>=0){
        console.log('是手机号码');
    }else{
        console.log('不是手机号码');
    }
}

```


```js
//判断用户输入的是不是邮箱。
function isEmail(str){
   if( str.match(/^\d{5,11}@.*?\.(com)$/g) != null){
        console.log('是邮箱');
   }else{
    console.log('不是邮箱');
   }
}
```